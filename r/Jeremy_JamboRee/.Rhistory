summary(fit)
summary(fit)
library(dplyr)
1+3
?log
a = c(1,2,1,2)
a
a = [1 2 1 2]
a = [1, 2, 1, 2]
a = (1, 2, 1)
a = 1:10
a
d = c(1,3)
d
a[d]
d
a
a = -10:10
a
a[d]
?matrix()
matrix(data = 0, nrow = 3, ncol = 2)
x = matrix(data = 0, nrow = 3, ncol = 2)
x
x = matrix(data = 1:6, nrow = 3, ncol = 2)
x
x = matrix(data = 1:8, nrow = 3, ncol = 2)
x = matrix(data = 1:5, nrow = 3, ncol = 2)
x = matrix(data = 1:6, nrow = 3, ncol = 2)
x
x = matrix(data = 1:6, nrow = 3, ncol = 2, byrow = t)
x = matrix(data = 1:6, nrow = 3, ncol = 2, byrow = TRUE)
x
x = matrix(data = 1:6, nrow = 3, ncol = 2, byrow = FALSE)
x
x[2,2]
x[1,2]
x[2:3, 1:2]
x[2:3, 1]
?data.frame
data.frame
data.frame(Var1 = 1:4, "Var2" = 4:8)
data.frame("Var1" = 1:4, "Var2" = 4:8)
a = 1:4, b = 4:8
a = 1:4; b = 4:8
a
b
a = 1:4; b = 4:7
data.frame("Var1" = a, "Var2" = b)
c = randu(4)
?rand
?randu
?Random
c = 2, 5, 7, 3
c = c(2, 5, 7, 3)
a
b
c
data.frame(a, b, c)
m = data.frame("Alex" = a, "Bob" = b, "Carl" = c)
m
nrow(m)
m[1]
m[1:2]
m[,3]
m[,2]
m[,1]
m[1]
m[1,2]
m[1,2:3]
m[1:2,3]
?rnorm
rnorm(n = 500, mean = 0, sd = 1)
rnorm(n = 500, mean = 0, sd = 1) * 10
df = rnorm(n = 500, mean = 0, sd = 1) * 10
?rep
df = rnorm(n = 500, mean = 224, sd = 12)
df
c(rep('a', 100, rep('b', 100), rep('c', 100), rep('d', 100), rep('e', 100)))
c(rep('a', 100, rep('b', 100), rep('c', 100), rep('d', 100), rep('e', 100))
c(rep('a', 100, rep('b', 100), rep('c', 100), rep('d', 100), rep('e', 100))
c(rep('a', 100), rep('b', 100), rep('c', 100), rep('d', 100), rep('e', 100))
dx = c(rep('a', 100), rep('b', 100), rep('c', 100), rep('d', 100), rep('e', 100))
dx
dx''
m
m = data.frame(numbers = a, letters = b)
m
numbers
letters
letters
numbers
head(m)
head(df)
df
n
n = 1:500
df
df = rnorm(n = 500, mean = 224, sd = 12)
df[end]
dx
df[,2]
df
dx[,2]
m
n
df
m
n
dx
df = rnorm(n = 500, mean = 224, sd = 12)
df
m = data.frame("Alex" = a, "Bob" = b, "Carl" = c)
m
df$col3 = 1:500
names(df)
df$prod = df$numbers * df$col3
df
head(df)
tail(df)
library(dplyr)
View(m)
View(x)
install.packages("dplyr")
library(dplyr)
head(df)
df = df %>% mutate(col3 = 1:500, prod = cold*numbers)
df = df %>% mutate(col3 = 1:500, prod = col3*numbers)
df = df %>% mutate(col3 = 1:500, prod = col3*numbers) # create new column
# Demonstration of some simple tasks with R
# First of all, text with a hash (#) symbol at its beginning is a comment. Comments are just for making our code
# more readable and better documented. They aren't interpreted by R.
## Do some math
1+3 # with your cursor on this line, press ctrl+enter
# Pressing Ctrl+enter runns the current line or the current selection in the "Console" window below
# Prove it to yourself by typing "1+3", without the qotes, into the Console window below, then hit "enter"
# Hopefully you get 4 as your result either way
# You can create "variables" to do the same task ----
a = 1 # create a variable, a, representing the number 1
a
A
b = 3
a+b
a*b
d = 5
d*(a+b)
d**b # double-star is exponent: "c to the power of b" in this case
?log # running a line like this, with a question mark prior to a function's name, brings up the help documentation for that function in the bottom-right window.
log(d, base=2)
# Vectorize your math ----
a = c(1,3,5,7) # c() is used to combine objects into a data structure called a "vector"
a
1:4 # can also make a vector of integers like so. In this case 1 through 4.
# What happens when you run each of the following lines?
a
a+b
b = c(1,2,1,2)
a+b
# Slicing (getting elements of) vectors by their index (position in the vector)
a
a[2] # square brackets after a variable for slicing. In this case, we're grabbing the 2nd element of a
a[2:3] # elements 2 through 3
a[c(1,3)] # get elements 1 and 3
d = c(1,3)
a[d] # can supply the indices we want to slice with a variable.
# Make a 2-dimensional matrix ----
matrix(data=0, nrow=3, ncol=2) # run this line and see what you get
matrix(data=1:6, nrow=3, ncol=2) # Now this one. Note the order in which the matrix gets filled with data.
?matrix
matrix(data=c(1,2,3,4,5,6), nrow=3, ncol=2, byrow=TRUE)
mat = matrix(data=c(1,2,3,4,5,6), nrow=3, ncol=2, byrow=TRUE)
mat
# Slicing a 2D matrix
mat[1,] # Note the comma. It separates the dimensions for slicing. Here, we've grabbed the first row, and all columns.
mat[1:2,] # First two rows
mat[,1] # First column
mat[c(1,3),2] # What does this do?
rowInd = c(1,3)
mat[rowInd,2]
# Make a dataframe ----
?data.frame
data.frame(Var1=c(1,2,3), "Var2"=c(4,5,6))
var1 = c(1,2,3)
var1
var2 = c(4,5,6)
data.frame("Var1"=var1, "Var2"=var2)
var3 = c('a','b','c')
df = data.frame("Var1"=var1, "Var2"=var2, "Var3"=var3)
df
# How many rows in df?
nrow(df)
# Slicing dataframes can be done in the same way as matrices, i.e., with square brackets
# Additionally, you can use '$' notation or the names of columns in the square brackets
df
df[,2] # get 2nd column
df[,"Var2"]
df$Var2
# you can also create new columns with '$' notation
df$Var4 = 1:nrow(df)
df
# Let's do something more interesting with a dataframe
?rnorm
a = rnorm(n=500, mean=0, sd=1) # randomly sample 500 times from a normal distribution with mean 0 and sd 1
a
?rep
b = c(rep(x='a',times=100),rep('b',100),rep('c',100),rep('d',100),rep('e',100)) # build a vector of letters. The 'rep' function repeats a value n times
# Note that in the above line, I first used rep by naming its arguments, x and times. You can also omit the argument names as long as they are in the correct order.
b
df = data.frame(numbers=a, letters=b) # dataframe with columns called "numbers" and "letters"
df
head(df) # get first few rows of df
##### POP QUIZ!!!!! #####
# Create a new column in df with integers 1 through 500
# Make another new column with the product of multiplying the values in this new column by those in the "numbers" column
df$col3 = 1:500
names(df)
df$prod = df$numbers * df$col3
head(df)
tail(df)
##### Now we'll do it with the dplyr package ----
# try using functions in dplyr
library(dplyr) # read in the functions defined in the dplyr package
head(df)
df = df %>% mutate(col3 = 1:500, prod = col3*numbers) # create new column
df
col3
col3
names(df)
df$prod = df$numbers * df$col3
df
names(df)
df$prod
head(df)
tail(df)
df %>% head
df
df[df > 0]
head(df[df > 0])
df %>% filter(numbers > 0)
head(df %>% filter(numbers > 0) )
df %>% filter(numbers > 0) %>% head
head(df[df$numbers > 0])
head(df$numbers)
head(df$numbers > 0)
filter(df$numbers > 0)
df[filter(df$numbers > 0)]
?mutate
df %>% mutate(col1 = 1) %>% head
df %>% mutate(col1 = 1, col2 = 2, col3 = col1+col2, col4 = col3*col2) %>% head # you can add multiple columns with a single call to mutate, and even use those columns within the call to mutate
df %>% summarise(numMean = mean(num))
df %>% summarise(numMean = mean(numbers))
df %>% summarise(numMean = mean(numbers), numMed = median(numbers), numsd = sd(numbers))
j = df %>% summarise(numMean = mean(numbers), numMed = median(numbers), numsd = sd(numbers))
j
df %>% group_by(letters) %>% summarise(numMean = mean(numbers), numMed = median(numbers), numsd = sd(numbers))
j = df %>% group_by(letters) %>% summarise(numMean = mean(numbers), numMed = median(numbers), numsd = sd(numbers))
j
newDF
newDF
newDF = df %>% group_by(letters) %>% mutate(newCol = numbers + mean(col3))
newDF
newDF
ls
l
dir
newDF
newDF %>% head()
newDF %>% tail
names(df)
library(ggplot2)
install.packages("ggplot2")
